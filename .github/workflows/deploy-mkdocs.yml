# نام Workflow که در تب Actions گیت‌هاب نمایش داده می‌شود
name: Deploy MkDocs to IIS - Enhanced Version

# تریگر: این Workflow چه زمانی اجرا شود؟
# در اینجا، هر زمان که کدی به برنچ main پوش شود
on:
  push:
    branches:
      - main  # یا master، بسته به نام برنچ اصلی شما

# تعریف کارها (Jobs)
jobs:
  build-and-deploy:
    # نام نمایشی Job
    name: Build and Deploy MkDocs Site Enhanced

    # مهم: مشخص می‌کنیم که این Job باید روی Runner شخصی ما اجرا شود
    runs-on: self-hosted

    # مراحل اجرای Job
    steps:
      # مرحله 1: دریافت آخرین نسخه کد از ریپازیتوری
      - name: Checkout Repository
        uses: actions/checkout@v4

      # مرحله 2: بررسی محیط و آماده‌سازی
      - name: Environment Check & Preparation
        shell: powershell
        run: |
          Write-Host "=== Environment Check ==="
          Set-Location "${{ github.workspace }}"
          Write-Host "Current directory: $(Get-Location)"
          
          # بررسی فایل mkdocs.yml
          if (Test-Path "mkdocs.yml") {
            Write-Host "✅ mkdocs.yml found"
          } else {
            Write-Host "❌ mkdocs.yml not found!"
            exit 1
          }
          
          # بررسی و ایجاد پوشه‌های مورد نیاز
          $requiredDirs = @("docs", "overrides", "stylesheets")
          foreach ($dir in $requiredDirs) {
            if (-not (Test-Path $dir)) {
              Write-Host "Creating missing directory: $dir"
              New-Item -ItemType Directory -Name $dir -Force
              
              # اضافه کردن فایل‌های پیش‌فرض در صورت نیاز
              if ($dir -eq "docs" -and -not (Test-Path "docs\index.md")) {
                "# Welcome`n`nThis is the homepage." | Out-File -FilePath "docs\index.md" -Encoding UTF8
              }
              if ($dir -eq "stylesheets" -and -not (Test-Path "stylesheets\custom.css")) {
                "/* Custom CSS */" | Out-File -FilePath "stylesheets\custom.css" -Encoding UTF8
              }
            } else {
              Write-Host "✅ Directory exists: $dir"
            }
          }

      # مرحله 3: تست MkDocs قبل از بیلد اصلی
      - name: Test MkDocs Configuration
        shell: powershell
        run: |
          Set-Location "${{ github.workspace }}"
          
          Write-Host "=== Testing MkDocs Configuration ==="
          
          # تست version
          Write-Host "MkDocs version:"
          python -m mkdocs --version
          
          # تست YAML parsing
          Write-Host "`nTesting YAML configuration parsing..."
          
          # ایجاد کد پایتون با خطوط جداگانه
          $pythonCode = 'import yaml' + "`n"
          $pythonCode += 'import sys' + "`n"
          $pythonCode += 'sys.stdout.reconfigure(encoding="utf-8")' + "`n"
          $pythonCode += 'with open("mkdocs.yml", "r", encoding="utf-8") as f:' + "`n"
          $pythonCode += '    config = yaml.safe_load(f)' + "`n"
          $pythonCode += '    print("✅ YAML parsing successful!")' + "`n"
          $pythonCode += '    print("Site name:", config.get("site_name", "Not found"))' + "`n"
          $pythonCode += '    theme_info = config.get("theme", {})' + "`n"
          $pythonCode += '    if isinstance(theme_info, dict):' + "`n"
          $pythonCode += '        theme_name = theme_info.get("name", "Not found")' + "`n"
          $pythonCode += '    else:' + "`n"
          $pythonCode += '        theme_name = str(theme_info)' + "`n"
          $pythonCode += '    print("Theme:", theme_name)'
          
          $pythonCode | Out-File -FilePath "test_config.py" -Encoding UTF8
          python test_config.py
          Remove-Item "test_config.py" -ErrorAction SilentlyContinue
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "❌ Configuration test failed!"
            exit $LASTEXITCODE
          }

      # مرحله 4: بیلد کردن سایت با دستور mkdocs build
      - name: Build MkDocs Site
        shell: powershell
        run: |
          Set-Location "${{ github.workspace }}"
          
          Write-Host "=== Building MkDocs Site ==="
          
          # تنظیم environment variables برای UTF-8
          $env:PYTHONIOENCODING = "utf-8"
          $env:LANG = "en_US.UTF-8"
          
          Write-Host "Running: python -m mkdocs build --clean --verbose"
          python -m mkdocs build --clean --verbose
          
          $buildExitCode = $LASTEXITCODE
          Write-Host "Build exit code: $buildExitCode"
          
          if ($buildExitCode -eq 0) {
            Write-Host "✅ Build successful!"
            
            # بررسی ایجاد شدن فایل‌های خروجی
            if (Test-Path "site") {
              $siteFiles = Get-ChildItem -Path "site" -Recurse -File
              Write-Host "Generated files count: $($siteFiles.Count)"
              
              # تشخیص مسیر صحیح source
              if (Test-Path "site\fa") {
                Write-Host "✅ FA-specific build directory found: site\fa"
                $global:SourcePath = "site\fa"
              } else {
                Write-Host "✅ Using main site directory: site"
                $global:SourcePath = "site"
              }
            } else {
              Write-Host "❌ Site directory not created!"
              exit 1
            }
          } else {
            Write-Host "❌ Build failed!"
            exit $buildExitCode
          }

      # مرحله 5: استقرار هوشمند در IIS
      - name: Smart Deploy to IIS
        shell: powershell
        run: |
          Write-Host "=== Smart IIS Deployment ==="
          
          # تنظیم مسیرها
          $targetPath = "C:\inetpub\wwwroot\webkesht_docs"
          
          # تشخیص مسیر صحیح source
          if (Test-Path "${{ github.workspace }}\site\fa") {
            $sourcePath = "${{ github.workspace }}\site\fa"
            Write-Host "✅ Using FA-specific build: $sourcePath"
          } else {
            $sourcePath = "${{ github.workspace }}\site"
            Write-Host "✅ Using main site build: $sourcePath"
          }

          Write-Host "Deploying from '$sourcePath' to '$targetPath'..."

          # === مرحله 1: مدیریت IIS (اختیاری) ===
          Write-Host "`n--- IIS Management (Optional) ---"
          try {
            Import-Module WebAdministration -ErrorAction SilentlyContinue
            
            $appPoolName = "webkesht_docs"
            $appPool = Get-IISAppPool -Name $appPoolName -ErrorAction SilentlyContinue
            
            if ($appPool) {
              Write-Host "Stopping Application Pool: $appPoolName"
              Stop-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 5
              Write-Host "✅ Application Pool stopped"
            }
          } catch {
            Write-Host "⚠️  IIS management skipped: $($_.Exception.Message)"
          }

          # === مرحله 2: ایجاد و تنظیم مجوزهای پوشه مقصد ===
          Write-Host "`n--- Target Directory Management ---"
          if (-not (Test-Path $targetPath)) {
            Write-Host "Creating target directory..."
            New-Item -ItemType Directory -Force -Path $targetPath
          }
          
          # تنظیم مجوزها
          try {
            $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
            icacls $targetPath /grant "${currentUser}:(OI)(CI)F" /T /C /Q
            icacls $targetPath /grant "IIS_IUSRS:(OI)(CI)F" /T /C /Q
            Write-Host "✅ Permissions set"
          } catch {
            Write-Host "⚠️  Permission warning: $($_.Exception.Message)"
          }

          # === مرحله 3: پاکسازی هوشمند ===
          Write-Host "`n--- Smart Cleanup ---"
          if (Test-Path $targetPath) {
            try {
              # محافظت از فایل‌های مهم سیستم (اگر وجود دارند)
              $protectedFiles = @("web.config", ".htaccess", "robots.txt")
              $backupPath = "$env:TEMP\iis_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
              
              # بکاپ فایل‌های محافظت شده
              foreach ($protectedFile in $protectedFiles) {
                $filePath = Join-Path $targetPath $protectedFile
                if (Test-Path $filePath) {
                  if (-not (Test-Path $backupPath)) {
                    New-Item -ItemType Directory -Force -Path $backupPath
                  }
                  Copy-Item $filePath "$backupPath\$protectedFile" -Force
                  Write-Host "Backed up: $protectedFile"
                }
              }
              
              # پاکسازی با retry mechanism
              $maxRetries = 3
              $retryCount = 0
              $cleanSuccess = $false
              
              while ($retryCount -lt $maxRetries -and -not $cleanSuccess) {
                try {
                  Get-ChildItem -Path $targetPath -Recurse -Force | 
                    Where-Object { $_.FullName -notlike "*backup*" } |
                    Remove-Item -Force -Recurse -ErrorAction Stop
                  $cleanSuccess = $true
                  Write-Host "✅ Directory cleaned successfully"
                } catch {
                  $retryCount++
                  Write-Host "Cleanup retry $retryCount/$maxRetries..."
                  Start-Sleep -Seconds 2
                }
              }
              
              # بازگردانی فایل‌های محافظت شده
              if (Test-Path $backupPath) {
                Copy-Item "$backupPath\*" $targetPath -Force -ErrorAction SilentlyContinue
                Remove-Item $backupPath -Recurse -Force -ErrorAction SilentlyContinue
                Write-Host "Protected files restored"
              }
              
            } catch {
              Write-Host "⚠️  Cleanup warning: $($_.Exception.Message)"
            }
          }

          # === مرحله 4: کپی هوشمند با ROBOCOPY ===
          Write-Host "`n--- Smart Copy with ROBOCOPY ---"
          try {
            $robocopyArgs = @(
              "`"$sourcePath`"",
              "`"$targetPath`"",
              "/E",           # کپی subdirectories
              "/R:2",         # 2 retry
              "/W:3",         # 3 second wait
              "/MT:2",        # multi-threaded
              "/XO"           # exclude older files
            )
            
            $robocopyCmd = "robocopy " + ($robocopyArgs -join " ")
            Write-Host "Running: $robocopyCmd"
            
            & cmd.exe /c $robocopyCmd
            $robocopyExitCode = $LASTEXITCODE
            
            # ROBOCOPY success codes: 0-7 are typically successful
            if ($robocopyExitCode -le 7) {
              Write-Host "✅ ROBOCOPY completed successfully (exit code: $robocopyExitCode)"
              $copySuccess = $true
            } else {
              throw "ROBOCOPY failed with exit code: $robocopyExitCode"
            }
          } catch {
            Write-Host "⚠️  ROBOCOPY failed: $($_.Exception.Message)"
            Write-Host "Falling back to PowerShell copy..."
            
            try {
              Copy-Item -Path "$sourcePath\*" -Destination $targetPath -Recurse -Force
              Write-Host "✅ PowerShell copy succeeded"
              $copySuccess = $true
            } catch {
              Write-Host "❌ All copy methods failed: $($_.Exception.Message)"
              exit 1
            }
          }

          # === مرحله 5: بررسی نتیجه ===
          Write-Host "`n--- Deployment Verification ---"
          if ($copySuccess) {
            try {
              $deployedFiles = Get-ChildItem -Path $targetPath -Recurse -File
              Write-Host "✅ Deployment successful!"
              Write-Host "Total files deployed: $($deployedFiles.Count)"
              
              # بررسی فایل‌های کلیدی
              $keyFiles = @("index.html")
              foreach ($keyFile in $keyFiles) {
                if (Test-Path (Join-Path $targetPath $keyFile)) {
                  Write-Host "✅ Key file exists: $keyFile"
                } else {
                  Write-Host "⚠️  Key file missing: $keyFile"
                }
              }
            } catch {
              Write-Host "⚠️  Verification warning: $($_.Exception.Message)"
            }
          }

          # === مرحله 6: راه‌اندازی مجدد IIS ===
          Write-Host "`n--- Restart IIS Services ---"
          try {
            if ($appPool) {
              Write-Host "Starting Application Pool: $appPoolName"
              Start-WebAppPool -Name $appPoolName -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 3
              Write-Host "✅ Application Pool restarted"
            }
          } catch {
            Write-Host "⚠️  IIS restart warning: $($_.Exception.Message)"
          }
          
          Write-Host "`n🎉 Smart deployment completed successfully!"
